<h1>The Core Principle of AI-Assisted Development: Verification Cost Determines Applicability</h1>
<p>In exploring AI-assisted development, I&#39;ve gradually discovered a critical limitation: <strong>Natural language itself is full of ambiguity, and without repeated confirmation and interaction, the output will increasingly deviate from expectations.</strong></p>
<h2>The Mathematical Model of Cumulative Deviation</h2>
<p>There&#39;s an interesting calculation: if the first description is only 90% accurate, and each subsequent description is also &quot;by feel&quot; at 90%, then after 10 iterations:</p>
<p><strong>0.9^10 ≈ 0.3487 ≈ 34.87%</strong></p>
<p>This means that without clear feedback loops, errors will amplify exponentially. This isn&#39;t a theoretical concern—it&#39;s a problem frequently encountered in actual development.</p>
<h2>Core Principle: Verification Cost Determines Applicability</h2>
<p><img src="/images/ai-generated/ai-verification-cost-principle.png" alt="Verification Cost and AI Applicability"></p>
<p><em>This image was generated by deapi.ai</em></p>
<p>Based on practical development experience, I&#39;ve summarized a core principle:</p>
<blockquote>
<p><strong>When using AI for any task, you can only build solidly within the scope where you can verify AI output correctness with minimal time cost.</strong></p>
</blockquote>
<p>The key to this principle is: <strong>If the verification cost exceeds the cost of manual completion, then using AI isn&#39;t worthwhile.</strong> Verification cost determines the applicability of AI.</p>
<h2>Low Verification Cost Scenarios</h2>
<h3>1. Code Generation</h3>
<ul>
<li><strong>Syntax Checking</strong>: Compiler/TypeScript immediately reports errors</li>
<li><strong>Simple Logic</strong>: Can tell right from wrong at a glance</li>
<li><strong>Refactoring Tasks</strong>: Test suites automatically verify</li>
</ul>
<h3>2. Content Generation</h3>
<ul>
<li><strong>Format Checking</strong>: Markdown/HTML rendering immediately shows results</li>
<li><strong>Fact Verification</strong>: Can quickly Google verify</li>
<li><strong>Structured Data</strong>: JSON Schema validation</li>
</ul>
<h3>3. Documentation Generation</h3>
<ul>
<li><strong>Format Correctness</strong>: Visible to the eye</li>
<li><strong>Link Validity</strong>: Click to test</li>
<li><strong>Grammar Checking</strong>: Spell-checking tools</li>
</ul>
<h2>High Verification Cost Scenarios (Use with Caution)</h2>
<ol>
<li><strong>Complex Business Logic</strong>: Requires deep domain knowledge</li>
<li><strong>Security-Related Code</strong>: Requires security review</li>
<li><strong>Performance Optimization</strong>: Requires benchmarking</li>
<li><strong>Architecture Design</strong>: Requires long-term verification</li>
</ol>
<h2>Practice in the VibeBlog Project</h2>
<p>Let me use the VibeBlog project as an example to analyze which parts best fit the &quot;low verification cost&quot; principle:</p>
<h3>1. TypeScript Type System</h3>
<pre><code class="language-typescript">export interface PostMeta {
  slug: string;
  title: string;
  titleEn?: string;
  date: string;
  tags: string[];
  tagsEn?: string[];
  summary?: string;
  summaryEn?: string;
  heroImage?: string;
  description?: string;
  descriptionEn?: string;
}
</code></pre>
<ul>
<li><strong>Verification Cost</strong>: Almost zero (compiler automatically checks)</li>
<li><strong>Errors immediately exposed</strong>, no manual testing needed</li>
</ul>
<h3>2. JSON Metadata Structure</h3>
<p>Each article&#39;s metadata is structured JSON:</p>
<ul>
<li><strong>Verification Cost</strong>: Very low (JSON format checking + visual scanning)</li>
<li><strong>Structured data</strong>, easy to spot missing fields or format errors</li>
</ul>
<h3>3. Visual Output (Svelte Components)</h3>
<p>All UI components can be viewed directly in the browser:</p>
<ul>
<li><strong>Verification Cost</strong>: Low (just open the browser to see)</li>
<li><strong>Follows practical verification principle</strong>: Use chrome-devtools to open the browser and actually test</li>
</ul>
<h3>4. Tag Index Generation Script</h3>
<pre><code class="language-typescript">// Write tags.json (Chinese)
const indexPathZh = path.join(INDEXES_DIR, &#39;tags.json&#39;);
fs.writeFileSync(indexPathZh, JSON.stringify(tagsIndexZh, null, 2), &#39;utf-8&#39;);

console.log(`✅ Successfully generated tag index`);
console.log(`   - Chinese tags: ${tagCountZh}`);
console.log(`   - English tags: ${tagCountEn}`);
console.log(`   - Total posts: ${totalPosts}`);
</code></pre>
<ul>
<li><strong>Verification Cost</strong>: Low (check output JSON + console statistics)</li>
<li><strong>Output is structured data</strong>, easy to verify</li>
</ul>
<h3>5. HTML Content Generation</h3>
<p>Markdown to HTML conversion process:</p>
<ul>
<li><strong>Verification Cost</strong>: Low (open HTML file or view in browser)</li>
<li><strong>Format conversion results</strong> can be immediately checked</li>
</ul>
<h2>Parts Requiring Higher Verification Cost</h2>
<p>Of course, there are also parts in the project that require higher verification costs:</p>
<ol>
<li><strong>Content Logic Correctness</strong>: Whether article content is accurate (requires domain knowledge)</li>
<li><strong>Routing Logic</strong>: Whether URL parameter handling is correct (requires testing multiple scenarios)</li>
<li><strong>Language Switching Logic</strong>: Whether Chinese/English switching is complete (requires testing all pages)</li>
</ol>
<h2>Strategy Recommendations</h2>
<p>Based on this principle, I recommend:</p>
<ol>
<li><strong>Establish Automated Verification</strong>: Tests, lint, type checking</li>
<li><strong>Visualize Output</strong>: Use browser to actually test and confirm</li>
<li><strong>Small Step Iterations</strong>: Only make small changes that can be immediately verified</li>
<li><strong>Clear Verification Standards</strong>: Define objective standards for &quot;correctness&quot;</li>
</ol>
<h2>Conclusion</h2>
<p><strong>The value of AI lies in amplifying your judgment, not replacing it.</strong> AI can only become a reliable tool within the scope where you can quickly verify.</p>
<p>This principle applies not only to code development but also to any work assisted by AI. Remember: <strong>Verification cost determines the applicability of AI.</strong> Only within the scope of low verification costs can you complete work solidly and avoid problems caused by cumulative deviation.</p>
<hr>
<p><em>This article is a summary based on practical development experience, hoping to help developers exploring AI-assisted development.</em></p>
