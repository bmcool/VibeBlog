<h1>SimVi：用自然語言生成遊戲 AI 行為樹的原型</h1>

<p>在遊戲開發中，為 NPC（非玩家角色）設計 AI 行為一直是個複雜且耗時的任務。傳統上，開發者需要手動編寫行為樹（Behavior Tree）或狀態機，這不僅需要深入的技術知識，還需要反覆測試和調整。但如果有個工具，能讓你用自然語言描述想要的行為，然後自動生成可執行的行為樹代碼呢？</p>

<p>這就是 <strong>SimVi</strong> 專案想要解決的問題：一個村莊模擬遊戲的原型，展示如何用自然語言指令生成遊戲 AI 的行為樹 DSL（Domain Specific Language），並在遊戲中即時執行。</p>

<h2>核心功能：從自然語言到行為樹</h2>

<p>SimVi 的核心創新在於將自然語言指令轉換為結構化的行為樹 DSL。例如，當你輸入：</p>

<blockquote>
<p>「讓這個村民持續採木頭，背包滿了就回倉庫存放。」</p>
</blockquote>

<p>系統會自動生成以下 DSL：</p>

<pre><code>BEHAVIOR Lumberjack:
  LOOP mode=forever:
    SELECTOR:
      SEQUENCE:
        CONDITION inventory(resource=wood) < 10
        ACTION move_to target=nearest(tree)
        ACTION gather resource=wood
      SEQUENCE:
        CONDITION inventory(resource=wood) >= 10
        ACTION move_to target=storage
        ACTION deposit resource=wood
</code></pre>

<p>這個 DSL 會被解析成抽象語法樹（AST），然後由行為樹運行時（Behavior Runtime）執行，控制遊戲中的村民行為。</p>

<h2>技術架構</h2>

<h3>1. 自然語言處理：OpenAI API 整合</h3>

<p>SimVi 使用 OpenAI 的 GPT-4o-mini 模型將自然語言轉換為 DSL。系統會提供詳細的系統提示詞（System Prompt），包含：</p>

<ul>
<li>DSL 語法規則</li>
<li>可用的動作（Actions）和條件（Conditions）</li>
<li>多個範例展示不同場景的轉換方式</li>
</li>
</ul>

<p>如果沒有提供 API Key，系統會使用 mock 版本，根據關鍵字匹配生成簡單的 DSL 範例。</p>

<h3>2. DSL 解析器</h3>

<p>DSL 解析器採用遞迴下降解析（Recursive Descent Parsing）的方式，支援以下節點類型：</p>

<ul>
<li><strong>BEHAVIOR</strong>：行為樹的根節點</li>
<li><strong>LOOP</strong>：循環執行（目前支援 mode=forever）</li>
<li><strong>SEQUENCE</strong>：順序執行，任一子節點失敗則失敗</li>
<li><strong>SELECTOR</strong>：選擇執行，任一子節點成功則成功</li>
<li><strong>CONDITION</strong>：條件判斷（如 inventory(resource=wood) >= 10）</li>
<li><strong>ACTION</strong>：動作執行（如 move_to, gather, deposit）</li>
</ul>

<p>解析器會檢查縮排（必須是 2 的倍數）、語法正確性，並提供詳細的錯誤訊息，包含行號和具體錯誤位置。</p>

<h3>3. 行為樹運行時</h3>

<p>行為樹運行時負責執行解析後的 AST，支援三種狀態：</p>

<ul>
<li><strong>success</strong>：節點執行成功</li>
<li><strong>failure</strong>：節點執行失敗</li>
<li><strong>running</strong>：節點正在執行中（如移動、等待）</li>
</ul>

<p>運行時會維護節點記憶體（Memory），用於保存長時間運行的動作狀態，例如：</p>

<ul>
<li>移動動作的目標位置</li>
<li>等待動作的開始時間</li>
<li>序列節點的當前執行索引</li>
</ul>

<h3>4. 複雜度計算與限制</h3>

<p>為了防止生成過於複雜的行為樹，SimVi 實現了複雜度計算機制。每個節點類型都有對應的成本：</p>

<ul>
<li>SEQUENCE: 1</li>
<li>SELECTOR: 2</li>
<li>LOOP: 3</li>
<li>CONDITION: 1</li>
<li>ACTION_basic: 1（如 move_to, gather）</li>
<li>ACTION_advanced: 3</li>
</ul>

<p>系統會計算整個行為樹的總複雜度，如果超過設定的上限（預設為 10），行為樹將不會執行。這可以類比為「村莊等級限制」：低等級村莊無法執行過於複雜的 AI 行為。</p>

<h3>5. 可視化：React Flow 整合</h3>

<p>SimVi 使用 React Flow 將行為樹 AST 可視化為流程圖，讓開發者可以直觀地看到生成的行為樹結構。每個節點顯示其類型和參數，邊（Edge）表示父子關係。</p>

<h3>6. 遊戲引擎：Phaser 3</h3>

<p>遊戲部分使用 Phaser 3 實現，包含：</p>

<ul>
<li>村民（藍色圓圈）：由行為樹控制</li>
<li>守衛（紅色圓圈）：簡單的巡邏邏輯</li>
<li>樹木（綠色圓圈）：可採集資源</li>
<li>倉庫（黃色矩形）：可存放資源</li>
</ul>

<p>遊戲世界狀態（World State）與 Phaser 場景同步，行為樹運行時每 100ms 執行一次 tick，更新村民的位置和狀態。</p>

<h2>實作細節</h2>

<h3>動作系統</h3>

<p>SimVi 實現了多種動作類型：</p>

<ul>
<li><strong>move_to</strong>：移動到指定目標（storage, nearest(tree), random）</li>
<li><strong>gather</strong>：採集資源（目前支援 wood）</li>
<li><strong>deposit</strong>：存放資源到倉庫</li>
<li><strong>wait</strong>：等待指定時間</li>
<li><strong>follow</strong>：持續跟隨目標（返回 running 狀態）</li>
<li><strong>follow_for_duration</strong>：跟隨目標指定時間後返回 success</li>
</ul>

<p>每個動作都會檢查前置條件，例如 gather 會檢查背包是否已滿，deposit 會檢查是否有資源可存放。</p>

<h3>條件系統</h3>

<p>目前支援的條件主要是庫存檢查：</p>

<ul>
<li><code>inventory(resource=wood) < 10</code>：庫存小於 10</li>
<li><code>inventory(resource=wood) >= 10</code>：庫存大於等於 10</li>
</ul>

<p>條件系統使用簡單的表達式解析，可以輕鬆擴展支援更多條件類型。</p>

<h3>世界狀態管理</h3>

<p>遊戲世界狀態（World State）包含：</p>

<ul>
<li>樹木列表（位置）</li>
<li>倉庫列表（位置、庫存）</li>
<li>村民列表（位置、庫存、容量）</li>
</ul>

<p>世界狀態提供查詢方法，例如：</p>

<ul>
<li><code>nearestTree(pos)</code>：找到最近的樹</li>
<li><code>nearestVillager(pos, excludeId)</code>：找到最近的村民（排除自己）</li>
<li><code>firstStorage()</code>：取得第一個倉庫</li>
</ul>

<h2>使用體驗</h2>

<p>SimVi 的介面分為兩個主要區域：</p>

<ul>
<li><strong>左側</strong>：Phaser 遊戲視圖，即時顯示村民行為</li>
<li><strong>右側</strong>：控制面板，包含：
  <ul>
    <li>OpenAI API Key 輸入（選填）</li>
    <li>自然語言指令輸入框</li>
    <li>DSL 編輯器</li>
    <li>複雜度顯示</li>
    <li>行為樹流程圖可視化</li>
  </ul>
</li>
</ul>

<p>使用流程：</p>

<ol>
<li>輸入自然語言指令（例如：「讓村民持續採木頭並回倉庫存放」）</li>
<li>點擊「由自然語言生成 DSL」按鈕</li>
<li>系統生成 DSL 並顯示在編輯器中</li>
<li>如果複雜度未超限，行為樹會自動執行</li>
<li>在遊戲視圖中觀察村民行為</li>
<li>可以手動編輯 DSL 進行微調</li>
</ol>

<h2>技術亮點</h2>

<h3>1. 類型安全</h3>

<p>整個專案使用 TypeScript 實現，確保類型安全。AST 節點、運行時配置、世界狀態都有完整的類型定義。</p>

<h3>2. 錯誤處理</h3>

<p>DSL 解析器提供詳細的錯誤訊息，包含行號、原始行內容和具體錯誤原因。如果 DSL 不合法，系統會顯示錯誤而不會崩潰。</p>

<h3>3. 可擴展性</h3>

<p>系統設計易於擴展：</p>

<ul>
<li>新增動作：在 <code>actions.ts</code> 中實現新的 ActionHandler</li>
<li>新增條件：在 <code>evaluateCondition.ts</code> 中添加條件評估邏輯</li>
<li>擴展 DSL 語法：修改解析器支援新的節點類型</li>
</ul>

<h3>4. 狀態持久化</h3>

<p>行為樹運行時使用記憶體（Memory）系統保存長時間運行的動作狀態，確保動作可以在多個 tick 之間保持連續性。</p>

<h2>未來展望</h2>

<p>SimVi 目前是一個原型，還有許多可以改進的方向：</p>

<ul>
<li><strong>更多動作類型</strong>：戰鬥、建造、交易等</li>
<li><strong>更複雜的條件</strong>：距離檢查、時間檢查、多資源檢查</li>
<li><strong>並行執行</strong>：支援多個行為樹同時執行</li>
<li><strong>行為樹編輯器</strong>：可視化編輯行為樹，而不只是查看</li>
<li><strong>更智能的 LLM 提示</strong>：根據遊戲狀態動態調整提示詞</li>
<li><strong>行為樹調試工具</strong>：可視化顯示當前執行節點、狀態轉換等</li>
</ul>

<h2>結語</h2>

<p>SimVi 展示了如何使用 AI 技術簡化遊戲開發中的 AI 行為設計。雖然目前還是原型階段，但它已經證明了自然語言到行為樹轉換的可行性。對於獨立遊戲開發者或小型團隊來說，這種工具可以大幅降低 AI 行為設計的門檻，讓開發者能夠更專注於遊戲玩法和內容創作。</p>

<p>更重要的是，SimVi 展示了 AI 輔助開發的一個重要原則：<strong>在驗證成本低的範圍內，AI 可以大幅提升開發效率</strong>。DSL 的語法檢查、行為樹的可視化、遊戲中的即時執行，都讓開發者能夠快速驗證 AI 生成的結果是否正確，這正是 AI 輔助開發最適合的場景。</p>

<p>如果你對這個專案感興趣，可以查看 <a href="https://www.youtube.com/watch?v=r3hk_gpsb8Y">Demo 影片</a> 了解實際運作情況。這個原型不僅展示了技術可能性，也為未來的遊戲開發工具提供了新的思路。</p>
