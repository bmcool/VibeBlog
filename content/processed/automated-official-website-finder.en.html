<h1>Automating Official Website Discovery for 1000+ Software Products: Design Logic of an Intelligent Search Script</h1>
<h2>Background: The Challenge of Moving from Manual to Automated Maintenance</h2>
<p><img src="/images/ai-generated/automated-official-website-finder.png" alt="Automation Workflow"></p>
<p>A software distributor was originally maintaining all products on their website manually. Facing over 1000 software products, each with different website structures, if crawlers had been written from the start, it would have been straightforward. But starting from scratch with no crawlers, achieving this overnight is not a simple task.</p>
<p>Initially, using agents like Cursor with Playwright MCP, we found that while it was possible, the efficiency was extremely poor, costs were high, and accuracy couldn&#39;t be trusted for large-scale runs. After trying several approaches, with various edge cases across 1000+ software products (disconnected official websites, products becoming sub-products, changed URLs, etc.), we realized we needed to proceed step by step.</p>
<p><strong>The first step was to recover the official websites for these software products.</strong> This is the mission of the <code>openai_web_search.py</code> script.</p>
<h2>Overall Script Architecture</h2>
<p>The core goal of this script is: <strong>automatically find the corresponding official website domain from a product name</strong>. The entire system is divided into three main layers:</p>
<ol>
<li><strong>WebSearchTool</strong>: Low-level web search tool responsible for actual searching and web page crawling</li>
<li><strong>OpenAISearchAssistant</strong>: Mid-level AI assistant responsible for optimizing search strategies and judging results</li>
<li><strong>Main Function Flow</strong>: Top-level batch processing logic responsible for reading products from the database and processing them in batches</li>
</ol>
<h2>Core Component One: WebSearchTool Class</h2>
<h3>Search Infrastructure</h3>
<p><code>WebSearchTool</code> uses <code>crawl4ai</code> as the underlying crawler engine, configured as follows:</p>
<pre><code class="language-python">self.browser_config = BrowserConfig(
    headless=True,
    verbose=False
)
self.run_config = CrawlerRunConfig(
    cache_mode=CacheMode.BYPASS,
    delay_before_return_html=2.0,  # Wait 2 seconds for page to load
    wait_for_images=False,
    screenshot=False
)
</code></pre>
<p>We chose <code>crawl4ai</code> over traditional <code>requests</code> because:</p>
<ul>
<li>Can handle JavaScript-rendered pages</li>
<li>Better anti-crawler resistance</li>
<li>Supports asynchronous operations for improved efficiency</li>
</ul>
<h3>Search Execution Logic</h3>
<p>The core flow of the <code>_search_with_language</code> method:</p>
<ol>
<li><p><strong>Build Search URL</strong>: Use DuckDuckGo&#39;s HTML search interface</p>
<pre><code class="language-python">search_url = f&quot;https://html.duckduckgo.com/html/?q={urllib.parse.quote(query)}&quot;
</code></pre>
</li>
<li><p><strong>Retry Mechanism</strong>: Retry up to 3 times, with increasing wait times between retries (10s, 20s, 30s)</p>
<ul>
<li>Special handling for 403 errors (rate limiting)</li>
<li>Other errors are also retried but logged and continued</li>
</ul>
</li>
<li><p><strong>Parse Search Results</strong>: Extract title, URL, and snippet from HTML</p>
<ul>
<li>Handle DuckDuckGo redirect URLs (<code>/l/?uddg=...</code> format)</li>
<li>Extract real target URLs</li>
</ul>
</li>
</ol>
<h3>Simple Official Domain Finding</h3>
<p>The <code>find_official_domain</code> method uses a score-based matching algorithm:</p>
<pre><code class="language-python"># Calculate matching score
score = 0

# Domain contains product name (case-insensitive) - highest priority
if product_name_clean in domain_lower:
    score += 10  # Domain matching is the most important indicator

# Title contains product name
if product_name.lower() in title:
    score += 5

# Title contains &quot;official&quot;
if &#39;official&#39; in title:
    score += 3

# Snippet contains product name
if product_name.lower() in snippet:
    score += 2

# Common official domain patterns (.com prioritized)
if &#39;.com&#39; in domain:
    score += 2
</code></pre>
<p>This method is simple and direct, but has limited accuracy because:</p>
<ul>
<li>Cannot distinguish between official and third-party websites</li>
<li>Cannot handle ambiguous product names</li>
<li>Cannot understand product descriptions to assist judgment</li>
</ul>
<h2>Core Component Two: Optimized Official Domain Finding</h2>
<h3>Why Optimization is Needed?</h3>
<p>Simple score-based matching encounters many problems in practical applications:</p>
<ul>
<li>Product names may have multiple expressions (e.g., &quot;Adobe Photoshop&quot; vs &quot;Photoshop&quot;)</li>
<li>Third-party websites may contain product names but are not official websites</li>
<li>Products may have been renamed or merged into other product lines</li>
</ul>
<p>Therefore, we need to introduce <strong>LLM for intelligent judgment</strong>.</p>
<h3>Three Stages of the Optimization Process</h3>
<h4>Stage One: Extract Search Keywords</h4>
<p>The <code>extract_product_search_keywords</code> method uses LLM to convert product names into 1-3 most effective search keywords:</p>
<pre><code class="language-python">extraction_prompt = f&quot;&quot;&quot;Please extract 1-3 English search keywords for the following product name. These keywords should be the ones most likely to find the official website.

Requirements:
1. If it&#39;s a Chinese product name, first translate to the official English name
2. Extract 1-3 keyword combinations, prioritized from high to low:
   - Company name + Product name (e.g., &quot;adobe photoshop&quot;)
   - Company name (e.g., &quot;adobe&quot;)
   - Product name (e.g., &quot;photoshop&quot;)
3. Only use official English names, avoid common words
</code></pre>
<p>The key to this stage is: <strong>finding keyword combinations that are most likely to find the official website</strong>, not the most complete product name.</p>
<h4>Stage Two: Sequential Search and Batch Judgment</h4>
<p>The core logic of the <code>find_official_domain_optimized</code> method:</p>
<ol>
<li><p><strong>Sequential Keyword Search</strong>: Search each keyword in priority order</p>
<pre><code class="language-python">for keyword_idx, keyword in enumerate(search_keywords, 1):
    results = await self.search(keyword, num_results=num_results_per_keyword)
</code></pre>
</li>
<li><p><strong>Extract Candidate Domains</strong>: Extract all possible domains from search results</p>
<ul>
<li>Handle DuckDuckGo redirect URLs</li>
<li>Deduplicate across keywords (keep each domain only once)</li>
</ul>
</li>
<li><p><strong>Batch LLM Judgment</strong>: Submit all candidate domains to LLM for judgment at once</p>
<pre><code class="language-python">async def judge_candidates(candidates: List[Dict[str, str]]) -&gt; List[Dict[str, Any]]:
    judgment_prompt = f&quot;&quot;&quot;Please judge whether the following websites are the official website of product &quot;{product_name}&quot;.
    
    Please carefully analyze each website to determine if it&#39;s the official website of this product. Consider:
    1. Whether the domain is related to the product name
    2. Whether the title and snippet match the product name and description
    3. Whether it looks like an official website (not third-party, news, dictionary sites, etc.)
    
    Please return a JSON array, each element corresponding to a website&#39;s judgment result:
    [
        {{
            &quot;domain&quot;: &quot;domain1&quot;,
            &quot;is_official&quot;: true/false,
            &quot;confidence&quot;: 0.0-1.0,
            &quot;reason&quot;: &quot;judgment reason&quot;
        }},
        ...
    ]
    &quot;&quot;&quot;
</code></pre>
</li>
<li><p><strong>Early Termination Strategy</strong>: If an official domain with confidence &gt; 0.9 is found, return immediately, skipping remaining keywords</p>
<pre><code class="language-python">if best_domain and best_confidence &gt; 0.9:
    print(f&quot;✅ Found high-confidence official domain: {best_domain}&quot;)
    return best_domain
</code></pre>
</li>
</ol>
<h3>Advantages of Batch Judgment</h3>
<p>Why batch judgment instead of one-by-one?</p>
<ol>
<li><strong>Cost Efficiency</strong>: One API call can judge multiple candidate domains, saving costs compared to individual calls</li>
<li><strong>Context Consistency</strong>: LLM can compare multiple candidate domains simultaneously for more accurate judgment</li>
<li><strong>Speed Improvement</strong>: Reducing API calls improves overall processing speed</li>
</ol>
<h3>Error Handling and Rate Limiting</h3>
<p>The script implements comprehensive error handling:</p>
<pre><code class="language-python"># If encountering 403 error, wait longer (30-60 seconds)
if &quot;403&quot; in error_msg or &quot;Forbidden&quot; in error_msg:
    delay = 30 + random.uniform(0, 30)  # 30-60 second random delay
    await asyncio.sleep(delay)
elif keyword != search_keywords[-1]:
    # Other errors also add delay (15-20 seconds)
    delay = 15 + random.uniform(0, 5)
    await asyncio.sleep(delay)
</code></pre>
<p>Key design points:</p>
<ul>
<li><strong>Random Delays</strong>: Avoid being identified as bot behavior</li>
<li><strong>Tiered Delays</strong>: 403 errors wait longer</li>
<li><strong>Continue Execution</strong>: Even if one keyword fails, continue processing the next</li>
</ul>
<h2>Core Component Three: Main Function Batch Processing Flow</h2>
<h3>Product Filtering Strategy</h3>
<p>The <code>main_async</code> function implements intelligent product filtering logic:</p>
<pre><code class="language-python"># Default behavior: Skip products with existing URLs, and products processed within 1 day
# But prioritize: products without URLs but with timestamps (representing failed fetches)
failed_products = []  # Products without URLs but with timestamps (prioritize)
new_products = []     # Products with no records at all

for product_id in all_product_ids[:args.limit * 3]:
    url_info = get_product_url_with_timestamp(conn, product_id)
    
    # If URL exists, skip
    if url_info and url_info.get(&#39;url&#39;):
        skip_count += 1
        continue
    
    # If processed within 1 day, skip (unless failed)
    if url_info and url_info.get(&#39;last_fetched_at&#39;):
        last_fetched = datetime.fromisoformat(...)
        if last_fetched.isoformat() &gt; one_day_ago:
            if not url_info.get(&#39;url&#39;):
                failed_products.append(product_id)  # Prioritize failed ones
            else:
                skip_count += 1
            continue
    
    # Categorize
    if url_info and url_info.get(&#39;last_fetched_at&#39;) and not url_info.get(&#39;url&#39;):
        failed_products.append(product_id)
    elif not url_info:
        new_products.append(product_id)

# Prioritize failed products, then process new products
product_ids_to_process = (failed_products + new_products)[:args.limit]
</code></pre>
<p>Advantages of this strategy:</p>
<ol>
<li><strong>Avoid Duplicate Processing</strong>: Products with existing URLs are skipped directly</li>
<li><strong>Prioritize Retrying Failures</strong>: Previously failed products are prioritized</li>
<li><strong>Time Window Control</strong>: Products processed within 1 day are skipped (unless failed)</li>
</ol>
<h3>Processing Flow</h3>
<p>The processing flow for each product:</p>
<pre><code class="language-python"># 1. Get product information
product_data = get_latest_version(conn, product_id)
product_name = product_data.get(&#39;name&#39;, &#39;&#39;)
product_desc1 = product_data.get(&#39;desc1&#39;, &#39;&#39;) or &#39;&#39;

# 2. Find official domain
official_domain = await find_official_domain_optimized(
    product_name=product_name,
    product_desc1=product_desc1,
    api_key=args.api_key
)

# 3. Save results
if official_domain:
    official_url = f&quot;https://{official_domain}&quot;
    set_product_url(conn, product_id, official_url)
    success_count += 1
else:
    # Official domain not found, clear existing URL but update fetch time
    delete_product_url(conn, product_id)
    update_product_url_fetched_time(conn, product_id)
    cleared_count += 1
</code></pre>
<p>Key design points:</p>
<ul>
<li><strong>Update timestamp even on failure</strong>: Avoid infinite retries of the same product</li>
<li><strong>Clear invalid URLs</strong>: If official domain not found, clear existing incorrect URLs</li>
<li><strong>Statistics</strong>: Record counts of success, failure, and skipped</li>
</ul>
<h2>Technical Details: URL Processing and Domain Extraction</h2>
<h3>DuckDuckGo Redirect Handling</h3>
<p>DuckDuckGo uses redirect URLs to protect user privacy, in the format <code>/l/?uddg=...</code>. The script needs to extract the real target URL:</p>
<pre><code class="language-python"># Handle DuckDuckGo redirect URLs
if url.startswith(&#39;//duckduckgo.com/l/&#39;) or url.startswith(&#39;/l/?&#39;):
    try:
        parsed = urllib.parse.urlparse(url if url.startswith(&#39;//&#39;) else f&quot;https:{url}&quot;)
        params = urllib.parse.parse_qs(parsed.query)
        if &#39;uddg&#39; in params:
            real_url = urllib.parse.unquote(params[&#39;uddg&#39;][0])
    except Exception as e:
        print(f&quot;⚠️  URL parsing failed: {url}, error: {e}&quot;)
        continue
</code></pre>
<h3>Domain Extraction Logic</h3>
<p>The <code>_extract_domain_from_url</code> method handles various URL formats:</p>
<pre><code class="language-python">def _extract_domain_from_url(self, url: str) -&gt; Optional[str]:
    # 1. Handle DuckDuckGo redirects
    if url.startswith(&#39;//duckduckgo.com/l/&#39;) or url.startswith(&#39;/l/?&#39;):
        # Extract real URL from uddg parameter
        ...
    
    # 2. Skip DuckDuckGo domains
    if &#39;duckduckgo.com&#39; in url.lower():
        return None
    
    # 3. If URL has no protocol, add https://
    if not url.startswith((&#39;http://&#39;, &#39;https://&#39;)):
        url = f&quot;https://{url}&quot;
    
    # 4. Parse domain
    parsed = urlparse(url)
    domain = parsed.netloc
    
    # 5. Remove www. prefix and port number
    if domain.startswith(&#39;www.&#39;):
        domain = domain[4:]
    if &#39;:&#39; in domain:
        domain = domain.split(&#39;:&#39;)[0]
    
    # 6. Validate domain format
    if &#39;.&#39; not in domain or len(domain.split(&#39;.&#39;)) &lt; 2:
        return None
    
    return domain
</code></pre>
<h2>Practical Application Results</h2>
<p>How does this script perform in practical applications?</p>
<h3>Advantages</h3>
<ol>
<li><strong>High Automation</strong>: Can batch process large numbers of products without manual intervention</li>
<li><strong>Improved Accuracy</strong>: Using LLM judgment is more accurate than simple keyword matching</li>
<li><strong>Controllable Costs</strong>: Batch judgment and early termination strategies reduce API call costs</li>
<li><strong>Error Recovery</strong>: Comprehensive retry mechanisms and error handling</li>
</ol>
<h3>Challenges</h3>
<ol>
<li><strong>Rate Limiting</strong>: DuckDuckGo and target websites may limit crawler access</li>
<li><strong>Edge Cases</strong>: Product renaming, mergers, disconnected official websites require manual handling</li>
<li><strong>Costs</strong>: Although optimized, LLM API calls still have costs</li>
</ol>
<h3>Improvement Directions</h3>
<ol>
<li><strong>Caching Mechanism</strong>: Cache processed products to avoid duplicate processing</li>
<li><strong>Concurrency Control</strong>: Improve concurrent processing while respecting rate limits</li>
<li><strong>Result Validation</strong>: Periodically verify if saved URLs are still valid</li>
</ol>
<h2>Conclusion</h2>
<p>The <code>openai_web_search.py</code> script demonstrates a practical automation solution that:</p>
<ol>
<li><strong>Layered Design</strong>: Separates search, judgment, and batch processing, each with clear responsibilities</li>
<li><strong>Intelligent Judgment</strong>: Uses LLM for semantic understanding, not simple keyword matching</li>
<li><strong>Cost Optimization</strong>: Batch processing and early termination strategies reduce API costs</li>
<li><strong>Error Handling</strong>: Comprehensive retry mechanisms and error recovery strategies</li>
<li><strong>Practical Usability</strong>: Designed for real-world scenarios with 1000+ software products, handling various edge cases</li>
</ol>
<p>This script not only solves the specific problem of &quot;recovering official websites&quot; but more importantly demonstrates how to balance automation level, accuracy, and cost in complex real-world scenarios.</p>
<hr>
<p><em>This article details the design logic of a script for automating the recovery of software official websites, hoping to help developers building similar automation systems.</em></p>
